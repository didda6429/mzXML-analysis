package lsi.sling.peakextraction;

import lsi.sling.FragmentHandling.AlignedFragmentCluster;
import lsi.sling.FragmentHandling.ClusteredAlignedFragmentCluster;
import lsi.sling.FragmentHandling.LCMS2Cluster;
import lsi.sling.databasehandling.Adduct;
import org.apache.commons.math3.ml.clustering.Cluster;
import org.apache.commons.math3.ml.clustering.DBSCANClusterer;
import org.apache.commons.math3.stat.StatUtils;
import org.apache.commons.math3.stat.descriptive.DescriptiveStatistics;

import java.util.ArrayList;
import java.util.List;

/**
 * This Class represents a cluster of PeakClusters which can be 'aligned' to correct for RT and m/z drifts. The intention
 * is for the clustering algorithm to be run somewhere else and the results to then be stored here.
 * @author Adithya Diddapur
 */
public class AlignedPeakCluster {

    private ArrayList<LCPeakCluster> clusters;
    private double medianMZ;
    private double medianRT;
    private int charge;
    private List<Adduct> adductList;

    private ArrayList<AlignedFragmentCluster> alignedFragmentClusters;
    private ArrayList<ClusteredAlignedFragmentCluster> characteristicFragments;

    private double targetMZAbove;
    private double targetMZBelow;

    /**
     * Creates an AlignedPeakCluster given a list of PeakClusters which belong to this specific cluster. The intention is
     * for the clustering algorithm to be run elsewhere (this class should be used to store the resulting data afterwards).
     * <p/>
     * When given an input list, this constructor handles the alignment step, and maps any possible adducts.
     * @param clusterList A list off all the LCPeakCluster objects which correspond to this cluster
     * @param ppm The ppm tolerance to use when mapping the adducts
     */
    public AlignedPeakCluster(List<LCPeakCluster> clusterList, int ppm){
        clusters = (ArrayList<LCPeakCluster>) clusterList;
        //Aligns the m/z and RT values
        medianMZ = new DescriptiveStatistics(clusters.stream().mapToDouble(LCPeakCluster::getMainMZ).toArray()).getPercentile(50);
        medianRT = new DescriptiveStatistics(clusters.stream().mapToDouble(LCPeakCluster::getMainRT).toArray()).getPercentile(50);

        //medianMZ = clusters.stream().mapToDouble(LCPeakCluster::getMainMZ).average().orElse(-1); //if there is an error in the stream, return -1
        //medianRT = clusters.stream().mapToDouble(LCPeakCluster::getMainRT).average().orElse(-1); //if there is an error in the stream, return -1
        int uniqueValues = clusters.stream().mapToInt(LCPeakCluster::getCharge).distinct().toArray().length;
        if(uniqueValues==1){
            charge = clusters.get(0).getCharge();
        } else {
            //if more than one unique charge, takes the first found mode
            charge = (int) Math.round(StatUtils.mode(clusters.stream().mapToDouble(LCPeakCluster::getCharge).toArray())[0]);
        }

        targetMZAbove = medianMZ + (medianMZ /1e6)*ppm;
        targetMZBelow = medianMZ - (medianMZ /1e6)*ppm;
        adductList = new ArrayList<>();
        System.gc();
    }

    /**
     * Finds all of the possible adducts for this AlignedPeakCluster using the list generated by AdductDatabase
     * @param adducts The list of Adducts of the same charge
     */
    public void findAdducts(List adducts){
        for(Adduct a : (Iterable<Adduct>) adducts){
            if(a.getResultMZ() < targetMZAbove && a.getResultMZ() > targetMZBelow){
                adductList.add(a);
            }
            if(a.getResultMZ() > targetMZAbove) break;
        }
    }

    /**
     * This method clusters the fragments in the LCPeakCluster objects to find the characteristic fragments for this
     * AlignedPeakCluster.
     */
    public void clusterFragments(){
        alignedFragmentClusters = new ArrayList<>();
        //Starts off by aligning the fragment M/Zs to correct for the RT drift
        for(LCPeakCluster cluster : clusters){
            for(LCMS2Cluster LCMS2Cluster : cluster.getFragmentClusters()){
                alignedFragmentClusters.add(new AlignedFragmentCluster(LCMS2Cluster, cluster.getMainRT()- medianRT));
            }
        }
        //Now let's cluster them based only on the M/Z (in 1 dimension)
        DBSCANClusterer<AlignedFragmentCluster> clusterer = new DBSCANClusterer<>(1, 0); //0 means only a single point
        List<Cluster<AlignedFragmentCluster>> clusterResults = clusterer.cluster(alignedFragmentClusters);
        //And store the clusters
        characteristicFragments = new ArrayList<>();
        for(Cluster<AlignedFragmentCluster> cluster : clusterResults){
            characteristicFragments.add(new ClusteredAlignedFragmentCluster(cluster));
        }
    }

    public ArrayList<AlignedFragmentCluster> getAlignedFragmentClusters(){
        return alignedFragmentClusters;
    }

    public void setAdductList(List<Adduct> list){
        adductList = list;
    }

    public ArrayList<LCPeakCluster> getClusters() {
        return clusters;
    }

    public double getMedianMZ() {
        return medianMZ;
    }

    public double getMedianRT() {
        return medianRT;
    }

    public List<Adduct> getAdductList(){
        return adductList;
    }

    public int getCharge(){
        return charge;
    }
}

package lsi.sling;

import org.apache.commons.math3.stat.StatUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * This Class represents a cluster of PeakClusters which can be 'aligned' to correct for RT and m/z drifts. The intention
 * is for the clustering algorithm to be run somewhere else and the results to then be stored here.
 * @author Adithya Diddapur
 */
public class AlignedPeakCluster {

    private ArrayList<PeakCluster> clusters;
    private double meanMZ;
    private double meanRT;
    private int charge;
    private List<Adduct> adductList;

    private double targetMZAbove;
    private double targetMZBelow;

    /**
     * Creates an AlignedPeakCluster given a list of PeakClusters which belong to this specific cluster. The intention is
     * for the clustering algorithm to be run elsewhere (this class should be used to store the resulting data afterwards).
     * <p/>
     * When given an input list, this constructor handles the alignment step, and maps any possible adducts.
     * @param clusterList A list off all the PeakCluster objects which correspond to this cluster
     * @param ppm The ppm tolerance to use when mapping the adducts
     */
    AlignedPeakCluster(List<PeakCluster> clusterList, int ppm){
        clusters = (ArrayList<PeakCluster>) clusterList;
        //Aligns the m/z and RT values
        meanMZ = clusters.stream().mapToDouble(PeakCluster::getMainMZ).average().orElse(-1); //if there is an error in the stream, return 0
        meanRT = clusters.stream().mapToDouble(PeakCluster::getMainRT).average().orElse(-1); //if there is an error in the stream, return 0
        int uniqueValues = clusters.stream().mapToInt(PeakCluster::getCharge).distinct().toArray().length;
        if(uniqueValues==1){
            charge = clusters.get(0).getCharge();
        } else {
            //if more than one unique charge, takes the first found mode
            charge = (int) Math.round(StatUtils.mode(clusters.stream().mapToDouble(PeakCluster::getCharge).toArray())[0]);
        }

        targetMZAbove = meanMZ + (meanMZ/1e6)*ppm;
        targetMZBelow = meanMZ - (meanMZ/1e6)*ppm;
        adductList = new ArrayList<>();
    }

    /**
     * Finds all of the possible adducts for this AlignedPeakCluster using the list generated by AdductDatabase
     * @param adducts The list of Adducts of the same charge
     */
    void findAdducts(List adducts){
        for(Adduct a : (Iterable<Adduct>) adducts){
            if(a.getResultMZ() < targetMZAbove && a.getResultMZ() > targetMZBelow){
                adductList.add(a);
            }
            if(a.getResultMZ() > targetMZAbove) break;
        }
    }

    public void setAdductList(List<Adduct> list){
        adductList = list;
    }

    public ArrayList<PeakCluster> getClusters() {
        return clusters;
    }

    public double getMeanMZ() {
        return meanMZ;
    }

    public double getMeanRT() {
        return meanRT;
    }

    public List<Adduct> getAdductList(){
        return adductList;
    }

    public int getCharge(){
        return charge;
    }
}

package lsi.sling;

import lsi.sling.FragmentHandling.AlignedFragmentCluster;
import lsi.sling.FragmentHandling.ClusteredAlignedFragmentCluster;
import lsi.sling.FragmentHandling.MS2Cluster;
import org.apache.commons.math3.ml.clustering.Cluster;
import org.apache.commons.math3.ml.clustering.DBSCANClusterer;
import org.apache.commons.math3.stat.StatUtils;

import java.util.ArrayList;
import java.util.List;

/**
 * This Class represents a cluster of PeakClusters which can be 'aligned' to correct for RT and m/z drifts. The intention
 * is for the clustering algorithm to be run somewhere else and the results to then be stored here.
 * @author Adithya Diddapur
 */
public class AlignedPeakCluster {

    private ArrayList<PeakCluster> clusters;
    private double meanMZ;
    private double meanRT;
    private int charge;
    private List<Adduct> adductList;

    private ArrayList<AlignedFragmentCluster> alignedFragmentClusters;
    private ArrayList<ClusteredAlignedFragmentCluster> characteristicFragments;

    private double targetMZAbove;
    private double targetMZBelow;

    /**
     * Creates an AlignedPeakCluster given a list of PeakClusters which belong to this specific cluster. The intention is
     * for the clustering algorithm to be run elsewhere (this class should be used to store the resulting data afterwards).
     * <p/>
     * When given an input list, this constructor handles the alignment step, and maps any possible adducts.
     * @param clusterList A list off all the PeakCluster objects which correspond to this cluster
     * @param ppm The ppm tolerance to use when mapping the adducts
     */
    AlignedPeakCluster(List<PeakCluster> clusterList, int ppm){
        clusters = (ArrayList<PeakCluster>) clusterList;
        //Aligns the m/z and RT values
        meanMZ = clusters.stream().mapToDouble(PeakCluster::getMainMZ).average().orElse(-1); //if there is an error in the stream, return -1
        meanRT = clusters.stream().mapToDouble(PeakCluster::getMainRT).average().orElse(-1); //if there is an error in the stream, return -1
        int uniqueValues = clusters.stream().mapToInt(PeakCluster::getCharge).distinct().toArray().length;
        if(uniqueValues==1){
            charge = clusters.get(0).getCharge();
        } else {
            //if more than one unique charge, takes the first found mode
            charge = (int) Math.round(StatUtils.mode(clusters.stream().mapToDouble(PeakCluster::getCharge).toArray())[0]);
        }

        targetMZAbove = meanMZ + (meanMZ/1e6)*ppm;
        targetMZBelow = meanMZ - (meanMZ/1e6)*ppm;
        adductList = new ArrayList<>();
    }

    /**
     * Finds all of the possible adducts for this AlignedPeakCluster using the list generated by AdductDatabase
     * @param adducts The list of Adducts of the same charge
     */
    void findAdducts(List adducts){
        for(Adduct a : (Iterable<Adduct>) adducts){
            if(a.getResultMZ() < targetMZAbove && a.getResultMZ() > targetMZBelow){
                adductList.add(a);
            }
            if(a.getResultMZ() > targetMZAbove) break;
        }
    }

    /**
     * This method clusters the fragments in the PeakCluster objects to find the characteristic fragments for this
     * AlignedPeakCluster.
     */
    void clusterFragments(){
        alignedFragmentClusters = new ArrayList<>();
        //Starts off by aligning the fragment M/Zs to correct for the RT drift
        for(PeakCluster cluster : clusters){
            for(MS2Cluster ms2Cluster : cluster.getFragmentClusters()){
                alignedFragmentClusters.add(new AlignedFragmentCluster(ms2Cluster, cluster.getMainRT()-meanRT));
            }
        }
        //Now let's cluster them based only on the M/Z (in 1 dimension)
        DBSCANClusterer<AlignedFragmentCluster> clusterer = new DBSCANClusterer<>(1, 0); //0 means only a single point
        List<Cluster<AlignedFragmentCluster>> clusterResults = clusterer.cluster(alignedFragmentClusters);
        //And store the clusters
        characteristicFragments = new ArrayList<>();
        for(Cluster<AlignedFragmentCluster> cluster : clusterResults){
            characteristicFragments.add(new ClusteredAlignedFragmentCluster(cluster));
        }
    }

    public ArrayList<AlignedFragmentCluster> getAlignedFragmentClusters(){
        return alignedFragmentClusters;
    }

    public void setAdductList(List<Adduct> list){
        adductList = list;
    }

    public ArrayList<PeakCluster> getClusters() {
        return clusters;
    }

    public double getMeanMZ() {
        return meanMZ;
    }

    public double getMeanRT() {
        return meanRT;
    }

    public List<Adduct> getAdductList(){
        return adductList;
    }

    public int getCharge(){
        return charge;
    }
}
